#!/usr/bin/python3
# -*- coding: utf-8 -*-

"""
Document Reader functions

This program is the mechanics for the Document Reader Program. It contains the functionality of
the buttons and the what and how different information is obtained and given.
The layout and design for the program is in reader.py and was generated by Qt Designer.
The final initialization is in main.py.

This program uses PyQt5.

author: Katie Davis
last edited: April 7, 2018
"""

from PyQt5 import QtWidgets, QtCore
from PyQt5.QtWidgets import QFileDialog, qApp
from PyQt5.QtCore import QBasicTimer
from reader import Ui_MainWindow
import os
import bs4 as bs
import urllib.request
from gtts import gTTS
import pygame
import docx
import threading


class ReaderWindow(QtWidgets.QMainWindow,Ui_MainWindow):
    def __init__(self):
        super().__init__()
        self.setupUi(self)
        self.Sound.hide()
        pygame.init()
        pygame.mixer.init()
        self.progressBar.hide()
        self.timer = QBasicTimer()
        self.step = 0
        self.show()

        # connect main screen buttons
        self.OpenFile.clicked.connect(self.open_pressed)
        self.WriteWebFile.clicked.connect(self.http_pressed)
        self.actionExit.triggered.connect(qApp.quit)

    # Creates sound file
    def play_pressed(self, file):
        name = self.SoundFileName.text()
        if name == '':
            self.OutputMessages.setText("Please name your file")
        else:
            self.progressBar.show()
            t = threading.Thread(name='progress', target=self.progress_measure())
            d = threading.Thread(name='gtts', target=self.tts_process(file))
            t.start()
            d.start()
            soundName = self.SoundFileName.text()
            soundName = soundName + ".mp3"
            pygame.mixer.init(frequency=8000)
            pygame.mixer.music.load(soundName)

        self.playButton.clicked.connect(self.start_playing)
        self.stopButton.clicked.connect(self.stop_playing)
        self.pauseButton.toggled.connect(self.pause_playing)

    # Create text to speech thread
    def tts_process(self, fileText):
        try:
            sound = self.SoundFileName.text()
            soundFile = gTTS(text=fileText, lang='en-us')
            sound = sound + ".mp3"
            soundFile.save(sound)
        except EOFError:
            self.OutputMessages.setText("Eof error: Please reboot program")
            self.Sound.hide()

    # Create progress measure thread, non_daemon
    def progress_measure(self):
        self.OutputMessages.setText("Website is being processed for speech. Please wait.")
        self.timer.start(100,self)

    def timerEvent(self, *args, **kwargs):
        if self.step >= 100:
            self.timer.stop()
            self.OutputMessages.setText("File is loaded and saved.")
            return
        self.step = self.step + 1
        self.progressBar.setValue(self.step)

    # Playback controls
    def start_playing(self):
        pygame.mixer.music.play(loops=0, start=0.0)

    def stop_playing(self):
        pygame.mixer.music.stop()

    # Code for toggle pause/unpause button
    @QtCore.pyqtSlot(bool)
    def pause_playing(self, checked):
        if checked:
            pygame.mixer.music.pause()
            self.pauseButton.setText("Unpause")
        elif not checked:
            pygame.mixer.music.unpause()
            self.pauseButton.setText("Pause")

    # open computer file, get fullText depending on doc type
    def open_pressed(self):
        options = QFileDialog.Options()
        options |= QFileDialog.DontUseNativeDialog
        fileName, _ = QFileDialog.getOpenFileName(self, "Select Text File", "",
                                                  "DocX Files (*.docx);; Text Files(*.txt)", '/home')
        if fileName.endswith(".docx"):
            doc = docx.Document(fileName)
            fullText = []
            for para in doc.paragraphs:
                fullText.append(para.text)
            fullText = '\n'.join(fullText)
        elif fileName.endswith(".txt"):
            f = open(fileName, 'r')
            with f:
                fullText = f.read()
        else:
            fullText = "Invalid file type"
        self.FileToOpen.setText(os.path.basename(fileName))
        self.Sound.show()
        self.PlaySound.clicked.connect(lambda: self.play_pressed(fullText))

    # Open web address, scrape for paragraph elements, and place in file variable for use
    def http_pressed(self):
        website = self.HttpAddress.text()
        try:
            http = urllib.request.urlopen(website).read()
            self.OutputMessages.setText("Website obtained.")
            soup = bs.BeautifulSoup(http, 'lxml')
            file = ''
            for paragraph in soup.find_all('p'):
                file += paragraph.text
            message = file

        except:
            message = "Website is not able to be scraped at this time"
        self.Sound.show()
        self.PlaySound.clicked.connect(lambda: self.play_pressed(message))